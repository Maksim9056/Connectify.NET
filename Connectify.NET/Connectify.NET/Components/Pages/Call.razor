@page "/call"
@rendermode InteractiveServer
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime

@using Microsoft.AspNetCore.Components.Web

<h1>Аудио / Видео звонок</h1>

<div>
    <video id="cameraPreview" width="320" height="240"></video>
    <video id="remoteVideo" autoplay onplaying="createPeerConnection" style="width: 320px; height: 240px;"></video>
    <video id="screenPreview" width="640" height="480"></video>
    <video id="cameraPreview" width="320" height="240"></video>

</div>

<div>
    <button id="joinButton" @onclick="JoinCall">Присоединиться к звонку</button>
    <button @onclick="EndCall">Завершить звонок</button>
    <button @onclick="EndCall">Завершить звонок</button>
    <button @onclick="StartRecording">Микрофон</button>
    <button @onclick="StartCamera">Start Camera</button>
    <button @onclick="StopCamera">Stop Camera</button>

    <button @onclick="StartScreenSharing">Start Screen Sharing</button>
    <button @onclick="StopScreenSharing">Stop Screen Sharing</button>

    <p id="callStatus">Статус: ожидание</p>
    <p>Поделитесь ссылкой с другими для присоединения:</p>
    <input type="text" id="callLink" readonly style="width: 300px;">
</div>

@code {

    private Func<Task> recordingFunc; // Функция для управления записью
    private IJSObjectReference videoElement;
    private async Task StartCamera()
    {
        try
        {
            if (videoElement == null)
            {
                videoElement = await JSRuntime.InvokeAsync<IJSObjectReference>("document.getElementById", "cameraPreview");
            }

            await JSRuntime.InvokeVoidAsync("startCamera", videoElement);
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error starting camera: " + ex.Message);
        }
    }

    private async Task StopCamera()
    {
        try
        {
            if (videoElement == null)
            {
                videoElement = await JSRuntime.InvokeAsync<IJSObjectReference>("document.getElementById", "screenPreview");
            }

            await JSRuntime.InvokeVoidAsync("stopCamera", videoElement);
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error stopping camera: " + ex.Message);
        }
    }

    private async Task StartRecording()
    {
        try
        {
            recordingFunc = await JSRuntime.InvokeAsync<Func<Task>>("startRecording");


      
            // Запись начата, можно выполнить дополнительные действия при необходимости
            Console.WriteLine("Recording started");
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error starting recording: " + ex.Message);
        }
    }


    async Task JoinCall()
    {

        
        await JSRuntime.InvokeAsync<string>("joinCall"); // this calls "window.PlaySound()"
                                                          // // Здесь будет код для присоединения к звонку
        // // Например, запрос разрешения на использование медиа-устройств
        await JSRuntime.InvokeAsync<string>("ReceiveOffer"); // this calls "window.PlaySound()"

        // try
        // {
        //     // const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        //     // const localVideo = document.getElementById('localVideo') as HTMLVideoElement;
        //     // localVideo.srcObject = stream;
        //     // localVideo.style.display = 'block';

        //     // Другой код для управления звонком
        // }
        // catch (err)
        // {
        //     console.error('Ошибка при получении доступа к медиа-устройствам:', err);
        // }
    }

    void EndCall()
    {
        // Здесь будет код для завершения звонка
        // Например, остановка медиа-потоков и обновление интерфейса
    }
    private async Task StartScreenSharing()
    {
        try
        {
            var videoElement = await JSRuntime.InvokeAsync<IJSObjectReference>("document.getElementById", "screenPreview");
            await JSRuntime.InvokeVoidAsync("startScreenSharing", videoElement);
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error starting screen sharing: " + ex.Message);
        }
    }

    private async Task StopScreenSharing()
    {
        try
        {
            var videoElement = await JSRuntime.InvokeAsync<IJSObjectReference>("document.getElementById", "screenPreview");
            await JSRuntime.InvokeVoidAsync("stopScreenSharing", videoElement);
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error stopping screen sharing: " + ex.Message);
        }
    }
}


<script>
    window.startRecording = function () {
        return new Promise((resolve, reject) => {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    const mediaRecorder = new MediaRecorder(stream);
                    const audioChunks = [];

                    mediaRecorder.addEventListener("dataavailable", event => {
                        audioChunks.push(event.data);
                    });

                    // Функция для завершения записи и возврата результата
                    const finishRecording = () => {
                        mediaRecorder.stop();
                        const audioBlob = new Blob(audioChunks);
                        const audioUrl = URL.createObjectURL(audioBlob);
                        resolve(audioUrl);
                    };

                    // Начать запись аудио
                    mediaRecorder.start();

                    // Возврат функции завершения записи для возможности остановки внешним вызовом
                    resolve(finishRecording);
                })
                .catch(error => {
                    reject(error);
                });
        });
    };
    window.startCamera = function (videoElement) {
        return new Promise((resolve, reject) => {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    videoElement.srcObject = stream;
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                })
                .catch(error => {
                    reject(error);
                });
        });
    };

    window.stopCamera = function (videoElement) {
        const stream = videoElement.srcObject;
        if (stream) {
            const tracks = stream.getTracks();
            tracks.forEach(track => {
                track.stop();
            });
            videoElement.srcObject = null;
        }
    };
    window.startScreenSharing = async function (videoElement) {
        try {
            const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => {
                videoElement.play();
            };
        } catch (error) {
            console.error('Error starting screen sharing:', error);
        }
    };

    window.stopScreenSharing = function (videoElement) {
        const stream = videoElement.srcObject;
        if (stream) {
            const tracks = stream.getTracks();
            tracks.forEach(track => {
                track.stop();
            });
            videoElement.srcObject = null;
        }
    };


</script>
@* 

    
<script>
    // Объявление переменных
    let peerConnection;
    let localStream;
    let callId;
    let connection; // Объявление переменной connection

    // Создание подключения к SignalR хабу
    connection = new signalR.HubConnectionBuilder()
        .withUrl("https://localhost:7068/webrtchub")
        .build();

    // Обработчики событий при получении сообщений от сервера
    connection.on("ReceiveOffer", async (offer) => {
        try {
            if (!peerConnection) {
                createPeerConnection();
            }
            await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: "offer", sdp: offer }));

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            await connection.invoke("SendAnswer", answer.sdp);

        } catch (error) {
            console.error('Ошибка при обработке предложения (offer):', error);
        }
    });

    connection.on("UpdateCallStatus", (status) => {
        document.getElementById('callStatus').innerText = `Статус: ${status}`;
    });

    connection.on("ReceiveCallId", (id) => {
        callId = id;
        document.getElementById('callLink').value = `${window.location.origin}/join/${id}`;
    });

    // Определение функции joinCall для присоединения к звонку
    async function joinCall() {
        try {
            const constraints = { audio: true, video: true }; // Включение аудио и видео
            // Получение доступа к медиапотоку (аудио и видео)
            const stream = await navigator.mediaDevices.getUserMedia(constraints);

            const localVideos = document.getElementById('localVideo');

            localStream = stream;
            createPeerConnection();

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            // Отправка оффера на сервер через SignalR
            const response = await connection.invoke("SendOffer", offer.sdp);
            callId = response.callId;
            document.getElementById('callLink').value = `${window.location.origin}/join/${callId}`;

            document.getElementById('callStatus').innerText = 'Статус: в звонке (прослушивание)';

        } catch (error) {
            console.error('Ошибка при присоединении к звонку:', error);
            alert('Невозможно присоединиться к звонку. Проверьте доступ к микрофону.');
        }
    }

    // Установка обработчика события на кнопку для вызова функции joinCall
    document.getElementById('joinButton').onclick = joinCall;

    // Обработка ICE кандидатов
    function handleIceCandidate(event) {
        if (event.candidate) {
            connection.invoke("SendIceCandidate", event.candidate.candidate, callId);
        }
    }

    // Создание объекта RTCPeerConnection
    function createPeerConnection() {
        peerConnection = new RTCPeerConnection();

        // Добавление треков медиапотока в RTCPeerConnection
        if (localStream) {
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
        }

        // Обработка удаленного потока
        peerConnection.ontrack = handleRemoteStreamAdded;
        peerConnection.onicecandidate = handleIceCandidate;
    }

    // Обработчик для добавления удаленного потока на видеоэлемент
    function handleRemoteStreamAdded(event) {
        const remoteVideo = document.getElementById('remoteVideo');
        remoteVideo.srcObject = event.streams[0];
    }

    // Функция для завершения звонка
    async function endCall() {
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }

        const remoteVideo = document.getElementById('remoteVideo');
        remoteVideo.srcObject = null;

        document.getElementById('callStatus').innerText = 'Статус: завершен';
    }

    // Запуск подключения к SignalR
    connection.start()
        .then(() => {
            console.log("SignalR подключен");
            connection.invoke("GetCurrentCallStatus");
        })
        .catch(err => console.error("Ошибка подключения к SignalR:", err));
</script>
 *@
@* 
<script>

    import {io} from 'socket.io-client';

const options = {
  "force new connection": true,
  reconnectionAttempts: "Infinity", // avoid having user reconnect manually in order to prevent dead clients after a server restart
  timeout : 10000, // before connect_error and connect_timeout are emitted.
  transports : ["websocket"]
}

const socket = io('/', options);

export default socket;
    const ACTIONS = {
        JOIN: 'join',
        LEAVE: 'leave',
        SHARE_ROOMS: 'share-rooms',
        ADD_PEER: 'add-peer',
        REMOVE_PEER: 'remove-peer',
        RELAY_SDP: 'relay-sdp',
        RELAY_ICE: 'relay-ice',
        ICE_CANDIDATE: 'ice-candidate',
        SESSION_DESCRIPTION: 'session-description'
    };

    module.exports = ACTIONS



</script>
   *@